async function e(e){const t=e.split("?"),r={url:e,hash:t[0]};if(1==t.length)return r;const s={},h=t[1].split("&");for(let e of h){const t=e.split("=");s[t[0]]=t[1]}return r.parameters=s,r}class t{constructor(e){this._router=e,this._hashChangedHandler=this._hashChanged.bind(this),window.addEventListener("hashchange",this._hashChangedHandler,!1),this._setUrl(this._router.routesDef.default).then(()=>this._router.goto(this._router.routesDef.default))}dispose(){delete this._router}async _hashChanged(t){if(1==this.mute)return delete this.mute;const r=await e(this._getHashFromString(t.oldURL)),s=await e(this._getHashFromString(t.newURL));if(this._router.viewModel&&this._router.viewModel.canLeave&&0==this._router.viewModel.canLeave(s.hash,s.parameters))return this.mute=!0,window.location.hash=r.url;this._router.viewModel&&r.hash==s.hash?(this._router.viewModel.parameters=s.parameters,this._router.viewModel.parametersChanged&&this._router.viewModel.parametersChanged(this._router.viewModel.parameters)):this._router.goto(s.hash,s.parameters,"hash")}async _setUrl(e){const t=this._router.routesDef.routes.find(t=>t.view===e);let r=[t.hash];if(t.parameters){r.push("?");for(let[e,s]of Object.entries(t.parameters))r.push(`${e}=${s}`)}window.location.hash=r.join("")}_getHashFromString(e){return e.substr(e.indexOf("#"),e.length)}}export{t as NavigationProvider};
